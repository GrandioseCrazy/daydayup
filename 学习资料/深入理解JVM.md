#JAVA内存区域与内存溢出异常
##运行时的数据区域
根据JAVA虚拟机规范，虚拟机所管理的内存将会分为以下几个运行时的数据区域
###方法区（线程共享）
主要存放虚拟机加载的类的信息、常量、静态变量、及时编译器编译后的代码等数据会有OOM产生
###堆区（线程共享）
所有的对象及数组都是在堆上分配的，也是垃圾收集的主要区域，会有OOM发生
###虚拟机栈（私有）
每个方法执行前都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接方法出口信息等 这里的局部变量表里存放了编译期可知的基本数据类型、对象的引用类型 64位长度的long和double会占用2个局部变量空间（Slot），虚拟机栈会抛出SOF和OOM
###本地方法栈（私有）
与虚拟机栈一样 只不过调用的是native方法
###程序计数器（私有）
较小的一块内存 为字节码的行号指示器 通过这个计数器来选取下一条需要执行的字节码指令 唯一一块没有规定任何OOM的区域

###运行时常量池
方法区的一部分，用于存放编译时期生成的各种字面量和符号引用

###直接内存
这块并不是虚拟机的运行书时数据区域，也不是JAVA虚拟机规范定义的区域、1.4 NIO引入后可以调用native方法直接分配堆外内存 会有OOM
##对象创建
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位一个符号引用，并检查这个符号引用的类是否被加载、解析和初始化，如果没有那就必须要先执行相应的类的加载
接下来就是要分配空间了，假设JAVA堆中的内存是绝对规整的，所有使用的内存放一边，所以分配内存只需要将“指针”移动要分配对象大小的位置，这种方式称为“指针碰撞”，如果JAVA内存并不是规整的，已使用内存和空闲内存相互交错，那就没办法进行“指针碰撞”了。虚拟机就必须要维护一个“空闲列表"，选择哪种方式就要根据JAVA堆是否规整，分配的时候也要考虑并发问题，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性，另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在JAVA堆中预先分配一块内存，称为本地线程分配缓冲，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要进行同步锁定，虚拟机是否使用TLAB，可以使用-XX:+/-UseTLAB参数来设定，分配完内存后要初始化内存（不包括对象头  ）